// Dans setup()
Servo myservo;
myservo.attach(5);  


void Distance() { 
   digitalWrite(Broche_Trigger, LOW); 
   delayMicroseconds(5); 
   digitalWrite(Broche_Trigger, HIGH); 
   delayMicroseconds(10); 
   digitalWrite(Broche_Trigger, LOW); 
   // Écoute de l'écho 
   Duree = pulseIn(Broche_Echo, HIGH); 
   // Calcul de la distance 
   Distance = Duree*0.034/2; 
   // Affichage de la distance dans le Moniteur Série 
   Serial.print("Distance : "); 
   Serial.print(Distance); 
   Serial.println("cm"); 
}

void ArmCommand(int motorID){
  const float ANGLE_MAX      = ?;    // en degrés
  const long  ANGLE_MIN      = ?;   // en degrés
  const float ANGLE_TOL      = 1.0;    // tolérance d'erreur en degrés
  const long  SPEED_CMD      = ?;  // centi-deg/s
  const float TARGET_ANGLE_ARM = 45.0; // angle cible en degrés
  const float distanceseuil = ?; // distance capteur à laquelle le bras va s'arreter de se lever
  double currentAngleArm = currentMotorPosDeg[2];
  float error = TARGET_ANGLE_ARM - currentAngleArm;
  while (true) {
    float currentAngleArm = currentMotorPosDeg[2];
    float error = TARGET_ANGLE_ARM - currentAngleArm;

    // sécurité pur le bras
    if (currentAngleArm >= ANGLE_MAX || currentAngleArm <= ANGLE_MIN) {
      sendVelocityCommand(motorID, 0);
      break;
    }

    // on lève le bras jusqu'à que la pince est au dessus du totem
    if (Distance < distanceseuil) {
      sendVelocityCommand(motorID, SPEED_CMD);
    }
    // quand la pince est finalement au dessus on cherche à atteindre un angle cible
    else {
      sendVelocityCommand(motorID, 0);
      delay(500);
      if (fabs(error) > ANGLE_TOL) {
        long cmd = (error > 0 ? SPEED_CMD : -SPEED_CMD);
        sendVelocityCommand(motorID, cmd);
      } else {
        // angle atteint : on stoppe le bras
        sendVelocityCommand(motorID, 0);

        delay(500);

        // faire avancer le robot légèrement
        sendVelocityCommand(MOTOR_ID_RIGHT, 50);
        sendVelocityCommand(MOTOR_ID_LEFT, 50);
        delay(300); // avance pendant 300 ms
        sendVelocityCommand(MOTOR_ID_RIGHT, 0);
        sendVelocityCommand(MOTOR_ID_LEFT, 0);

        // fermer la pince
        myservo.write(160);

        break; 
      }
    }

    delay(20); 
  }
}
