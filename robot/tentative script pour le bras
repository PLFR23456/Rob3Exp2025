// Dans setup()
Servo myservo;
myservo.attach(5);  
//dans setup () penser à avoir 2 couple echo/trig différents pcq on a 2 capteurs
const int TRIG_1 2
const int ECHO_1 3
pinMode(TRIG_1, OUTPUT);
pinMode(ECHO_1, INPUT);
long Distance1=distancecm(2,3);

const int TRIG_2 4
const int ECHO_2 5
pinMode(TRIG_2, OUTPUT);
pinMode(ECHO_2, INPUT);
long Distance2=distancecm(4,5);

float distancecm(const int Broche_Trigger, const int Broche_Echo) { 
   pinMode(Broche_Trigger, OUTPUT);
   pinMode(Broche_Echo, INPUT);
   digitalWrite(Broche_Trigger, LOW); 
   delayMicroseconds(2); 
   digitalWrite(Broche_Trigger, HIGH); 
   delayMicroseconds(10); 
   digitalWrite(Broche_Trigger, LOW); 
   // Écoute de l'écho 
   long Duree = pulseIn(Broche_Echo, HIGH); 
   // Calcul de la distance 
   long Distance1 = Duree*0.034/2;
   delay(10); 
   return Distance1;
}


void ArmCommand(int motorID){
  const float ANGLE_MAX      = ?;    // en degrés
  const long  ANGLE_MIN      = ?;   // en degrés
  const float ANGLE_TOL      = 1.0;    // tolérance d'erreur en degrés
  const long  SPEED_CMD      = ?;  // centi-deg/s
  const float TARGET_ANGLE_ARM = 45.0; // angle cible en degrés
  const float distanceseuil = ?; // distance capteur à laquelle le bras va s'arreter de se lever
  double currentAngleArm = currentMotorPosDeg[2];
  float error = TARGET_ANGLE_ARM - currentAngleArm;
  while (true) {
    float currentAngleArm = currentMotorPosDeg[2];
    float error = TARGET_ANGLE_ARM - currentAngleArm;

    // sécurité pur le bras
    if (currentAngleArm >= ANGLE_MAX || currentAngleArm <= ANGLE_MIN) {
      sendVelocityCommand(motorID, 0);
      break;
    }

    // on lève le bras jusqu'à que la pince est au dessus du totem
    if (Distance1 < distanceseuil) {
      sendVelocityCommand(motorID, SPEED_CMD);
    }
    // quand la pince est finalement au dessus on cherche à atteindre un angle cible
    else {
      sendVelocityCommand(motorID, 0);
      delay(500);
      if (fabs(error) > ANGLE_TOL) {
        long cmd = (error > 0 ? SPEED_CMD : -SPEED_CMD);
        sendVelocityCommand(motorID, cmd);
      } else {
        // angle atteint : on stoppe le bras
        sendVelocityCommand(motorID, 0);

        delay(500);

        // faire avancer le robot légèrement
        sendVelocityCommand(MOTOR_ID_RIGHT, 50);
        sendVelocityCommand(MOTOR_ID_LEFT, 50);
        delay(300); // avance pendant 300 ms
        sendVelocityCommand(MOTOR_ID_RIGHT, 0);
        sendVelocityCommand(MOTOR_ID_LEFT, 0);

        // fermer la pince
        myservo.write(160);

        break; 
      }
    }

    delay(20); 
  }
}
